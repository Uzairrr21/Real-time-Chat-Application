{"ast":null,"code":"var _s = $RefreshSig$();\nimport { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport axios from 'axios';\nimport { io } from 'socket.io-client';\nimport AuthContext from './AuthContext';\nconst ChatContext = /*#__PURE__*/createContext();\nexport const ChatProvider = ({\n  children\n}) => {\n  _s();\n  const [messages, setMessages] = useState([]);\n  const [onlineUsers, setOnlineUsers] = useState([]);\n  const [typingUsers, setTypingUsers] = useState([]);\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\n  const {\n    user,\n    isAuthenticated,\n    token,\n    logout\n  } = useContext(AuthContext);\n\n  // Stable WebSocket connection with retry\n  const connectSocket = useCallback(() => {\n    if (!isAuthenticated || !token) return;\n    const newSocket = io('http://localhost:3000', {\n      path: '/socket.io/',\n      auth: {\n        token\n      },\n      transports: ['websocket'],\n      reconnection: true,\n      reconnectionAttempts: Infinity,\n      reconnectionDelay: 1000,\n      reconnectionDelayMax: 5000,\n      timeout: 10000\n    });\n    newSocket.on('connect', () => {\n      setConnectionStatus('connected');\n      console.log('Socket connected');\n    });\n    newSocket.on('disconnect', reason => {\n      setConnectionStatus('disconnected');\n      console.log('Socket disconnected:', reason);\n    });\n    newSocket.on('connect_error', err => {\n      setConnectionStatus('error');\n      console.error('Connection error:', err);\n    });\n\n    // Message handlers\n    newSocket.on('message', message => {\n      setMessages(prev => [...prev, message]);\n    });\n    newSocket.on('onlineUsers', users => {\n      setOnlineUsers(users);\n    });\n    newSocket.on('typing', ({\n      userId,\n      isTyping\n    }) => {\n      setTypingUsers(prev => isTyping ? [...prev.filter(id => id !== userId), userId] : prev.filter(id => id !== userId));\n    });\n    setSocket(newSocket);\n    return () => newSocket.disconnect();\n  }, [isAuthenticated, token]);\n  useEffect(() => {\n    const cleanup = connectSocket();\n    return cleanup;\n  }, [connectSocket]);\n\n  // Robust API requests with retry\n  const apiRequest = async (config, retries = 3) => {\n    try {\n      const response = await axios({\n        ...config,\n        headers: {\n          ...config.headers,\n          'x-auth-token': token\n        }\n      });\n      return response.data;\n    } catch (err) {\n      var _err$response;\n      if (((_err$response = err.response) === null || _err$response === void 0 ? void 0 : _err$response.status) === 401) {\n        logout();\n        throw err;\n      }\n      if (retries > 0) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n        return apiRequest(config, retries - 1);\n      }\n      throw err;\n    }\n  };\n  const fetchMessages = useCallback(async () => {\n    try {\n      const data = await apiRequest({\n        method: 'get',\n        url: '/api/messages'\n      });\n      setMessages(data);\n    } catch (err) {\n      console.error('Failed to fetch messages:', err);\n    }\n  }, [token, logout]);\n  const sendMessage = async content => {\n    try {\n      const data = await apiRequest({\n        method: 'post',\n        url: '/api/messages',\n        data: {\n          content\n        }\n      });\n      socket.emit('message', data);\n      return data;\n    } catch (err) {\n      console.error('Failed to send message:', err);\n      throw err;\n    }\n  };\n\n  // ... rest of the context provider\n};\n_s(ChatProvider, \"+uEw7eAKyl8me/iQX66eVWBnpAo=\");\n_c = ChatProvider;\nvar _c;\n$RefreshReg$(_c, \"ChatProvider\");","map":{"version":3,"names":["createContext","useState","useEffect","useContext","useCallback","axios","io","AuthContext","ChatContext","ChatProvider","children","_s","messages","setMessages","onlineUsers","setOnlineUsers","typingUsers","setTypingUsers","connectionStatus","setConnectionStatus","user","isAuthenticated","token","logout","connectSocket","newSocket","path","auth","transports","reconnection","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","timeout","on","console","log","reason","err","error","message","prev","users","userId","isTyping","filter","id","setSocket","disconnect","cleanup","apiRequest","config","retries","response","headers","data","_err$response","status","Promise","resolve","setTimeout","fetchMessages","method","url","sendMessage","content","socket","emit","_c","$RefreshReg$"],"sources":["C:/Users/DELL/OneDrive/Desktop/mern-chat-app/frontend/src/context/ChatContext.js"],"sourcesContent":["import { createContext, useState, useEffect, useContext, useCallback } from 'react';\r\nimport axios from 'axios';\r\nimport { io } from 'socket.io-client';\r\nimport AuthContext from './AuthContext';\r\n\r\nconst ChatContext = createContext();\r\n\r\nexport const ChatProvider = ({ children }) => {\r\n  const [messages, setMessages] = useState([]);\r\n  const [onlineUsers, setOnlineUsers] = useState([]);\r\n  const [typingUsers, setTypingUsers] = useState([]);\r\n  const [connectionStatus, setConnectionStatus] = useState('disconnected');\r\n  const { user, isAuthenticated, token, logout } = useContext(AuthContext);\r\n\r\n  // Stable WebSocket connection with retry\r\n  const connectSocket = useCallback(() => {\r\n    if (!isAuthenticated || !token) return;\r\n\r\n    const newSocket = io('http://localhost:3000', {\r\n      path: '/socket.io/',\r\n      auth: { token },\r\n      transports: ['websocket'],\r\n      reconnection: true,\r\n      reconnectionAttempts: Infinity,\r\n      reconnectionDelay: 1000,\r\n      reconnectionDelayMax: 5000,\r\n      timeout: 10000\r\n    });\r\n\r\n    newSocket.on('connect', () => {\r\n      setConnectionStatus('connected');\r\n      console.log('Socket connected');\r\n    });\r\n\r\n    newSocket.on('disconnect', (reason) => {\r\n      setConnectionStatus('disconnected');\r\n      console.log('Socket disconnected:', reason);\r\n    });\r\n\r\n    newSocket.on('connect_error', (err) => {\r\n      setConnectionStatus('error');\r\n      console.error('Connection error:', err);\r\n    });\r\n\r\n    // Message handlers\r\n    newSocket.on('message', (message) => {\r\n      setMessages(prev => [...prev, message]);\r\n    });\r\n\r\n    newSocket.on('onlineUsers', (users) => {\r\n      setOnlineUsers(users);\r\n    });\r\n\r\n    newSocket.on('typing', ({ userId, isTyping }) => {\r\n      setTypingUsers(prev => \r\n        isTyping \r\n          ? [...prev.filter(id => id !== userId), userId]\r\n          : prev.filter(id => id !== userId)\r\n      );\r\n    });\r\n\r\n    setSocket(newSocket);\r\n    return () => newSocket.disconnect();\r\n  }, [isAuthenticated, token]);\r\n\r\n  useEffect(() => {\r\n    const cleanup = connectSocket();\r\n    return cleanup;\r\n  }, [connectSocket]);\r\n\r\n  // Robust API requests with retry\r\n  const apiRequest = async (config, retries = 3) => {\r\n    try {\r\n      const response = await axios({\r\n        ...config,\r\n        headers: {\r\n          ...config.headers,\r\n          'x-auth-token': token\r\n        }\r\n      });\r\n      return response.data;\r\n    } catch (err) {\r\n      if (err.response?.status === 401) {\r\n        logout();\r\n        throw err;\r\n      }\r\n      \r\n      if (retries > 0) {\r\n        await new Promise(resolve => setTimeout(resolve, 1000));\r\n        return apiRequest(config, retries - 1);\r\n      }\r\n      \r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const fetchMessages = useCallback(async () => {\r\n    try {\r\n      const data = await apiRequest({\r\n        method: 'get',\r\n        url: '/api/messages'\r\n      });\r\n      setMessages(data);\r\n    } catch (err) {\r\n      console.error('Failed to fetch messages:', err);\r\n    }\r\n  }, [token, logout]);\r\n\r\n  const sendMessage = async (content) => {\r\n    try {\r\n      const data = await apiRequest({\r\n        method: 'post',\r\n        url: '/api/messages',\r\n        data: { content }\r\n      });\r\n      socket.emit('message', data);\r\n      return data;\r\n    } catch (err) {\r\n      console.error('Failed to send message:', err);\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  // ... rest of the context provider\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}